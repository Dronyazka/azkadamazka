diff --git a/index.html b/index.html
index 57f4db3af80e682e4a149f729de031d47d05b158..dc61be2f38cee0e252e1c06a507ea4b663b28173 100644
--- a/index.html
+++ b/index.html
@@ -120,52 +120,53 @@ def _make_digamma():
         try:
             _ = mp.polygamma(0, mp.mpf('0.5'))
             return lambda z: mp.polygamma(0, z)
         except Exception:
             try:
                 _ = mp.digamma(mp.mpf('0.5'))
                 return lambda z: mp.digamma(z)
             except Exception:
                 def fallback(z):
                     h = mp.power(10, -10)
                     return (log(gamma(z + h)) - log(gamma(z - h))) / (2*h)
                 return fallback
     except Exception:
         try:
             _ = mp.polygamma(0, mp.mpf('0.5'))
             return lambda z: mp.polygamma(0, z)
         except Exception:
             def fallback(z):
                 h = mp.power(10, -10)
                 return (log(gamma(z + h)) - log(gamma(z - h))) / (2*h)
             return fallback
 
 digamma = _make_digamma()
 
 # ----- formatting: explicit exponent decision -----
-BIG_EXP = 15        # 10^15
-SMALL_EXP = -10     # 10^-10
+SIGNIFICAND = 15
+BIG_EXP = SIGNIFICAND   # 10^[significand]
+SMALL_EXP = -10         # 10^-10
 INT_TOL = mp.power(10, -20)
 
 def _fmt_sci(z):
     # ensure 15 significant digits and e-notation
     s = mp.nstr(z, 15, min_fixed=0)
     return s
 
 def _fmt_fixed(z):
     # produce a fixed-form string with up to 15 significant digits, no trailing zeros
     s = mp.nstr(z, 15)  # often uses fixed form for moderate magnitudes
     if 'e' in s or 'E' in s:
         # expand to more digits and then trim - this is a fallback when mp.nstr returned sci
         s = mp.nstr(z, 50, min_fixed=1)
     # trim trailing zeros
     if '.' in s:
         s = s.rstrip('0').rstrip('.')
     if s in ('-0', '+0'):
         return '0'
     return s
 
 def fmt(z):
     # handle inf/overflow
     try:
         if mp.isinf(z) or abs(z) > mp.mpf('1e300'):
             return '∞̃'
@@ -195,62 +196,65 @@ def fmt(z):
             # magnitude check
             try:
                 exp = mp.floor(mp.log10(abs(val)))
             except Exception:
                 exp = None
             if exp is None:
                 return _fmt_fixed(val)
             if exp >= BIG_EXP or exp < SMALL_EXP:
                 return _fmt_sci(val)
             return _fmt_fixed(val)
         # both parts possibly need different formatting
         try:
             exp_re = mp.floor(mp.log10(abs(re))) if re != 0 else 0
         except Exception:
             exp_re = 0
         try:
             exp_im = mp.floor(mp.log10(abs(im))) if im != 0 else 0
         except Exception:
             exp_im = 0
         re_s = _fmt_sci(re) if (abs(re) != 0 and (exp_re >= BIG_EXP or exp_re < SMALL_EXP)) else _fmt_fixed(re)
         im_s = _fmt_sci(abs(im)) if (abs(im) != 0 and (exp_im >= BIG_EXP or exp_im < SMALL_EXP)) else _fmt_fixed(abs(im))
         sign = ' + ' if mp.sign(im) >= 0 else ' - '
         return f\"{re_s}{sign}{im_s}i\"
 
     # real mpf
+    # exponent
+    try:
+        abs_z = abs(z)
+        exp = mp.floor(mp.log10(abs_z))
+    except Exception:
+        exp = None
+
+    # keep exact integer rendering only while value is below scientific cutoff
     try:
         nearest = int(mp.floor(z + mp.mpf('0.5')))
-        if abs(z - nearest) <= INT_TOL:
+        if abs(z - nearest) <= INT_TOL and abs_z < mp.power(10, BIG_EXP):
             return str(int(nearest))
     except Exception:
         pass
 
-    # exponent
-    try:
-        exp = mp.floor(mp.log10(abs(z)))
-    except Exception:
-        exp = None
     if exp is None:
         return _fmt_fixed(z)
     if exp >= BIG_EXP or exp < SMALL_EXP:
         return _fmt_sci(z)
     return _fmt_fixed(z)
 
 # ----- parsing & helpers -----
 def parse_input(s):
     s = s.strip()
     if s == '':
         raise ValueError('empty input')
     if ('i' not in s) and ('j' not in s):
         try:
             return mp.mpf(s)
         except Exception:
             pass
     try:
         return mpc(s.replace('i','j'))
     except Exception:
         raise ValueError('cannot parse input')
 
 def is_exact_real_integer(x):
     if isinstance(x, mpc):
         return False
     try:
@@ -315,55 +319,63 @@ def f_klimek(x):
         return mp.mpf('inf')
 
 # ----- Ulgenes: cached + faster inner k-sums + relative stopping -----
 _inner_cache = [mp.mpf('0')]   # index 0 unused, inner_cache[n] = inner sum for that n
 _ul_cache = {}                 # memoization: key -> mp.mpf result
 
 def _ensure_inner_cache(n_max):
     if len(_inner_cache) >= n_max + 1:
         return
     start = len(_inner_cache)
     for n in range(start, n_max + 1):
         inner = mp.mpf('0')
         # integer comb via math.comb
         for k in range(1, n + 1):
             sign = -1 if ((n + k) % 2) else 1
             coeff = mp.mpf(math.comb(2*n - 1, n - k))
             term_k = mp.mpf(2*k - 1) * coeff * mp.log(mp.mpf(k))
             inner += (-term_k if sign == -1 else term_k)
         _inner_cache.append(inner)
 
 def _ul_key(x):
     # string key at modest precision to identify equal/similar inputs
     return mp.nstr(x, 40)
 
 def ulgenes_direct(x):
+    # Ulgenes extension agrees with factorial on nonnegative integers.
+    # Use direct gamma there for a major speedup on large integer inputs.
+    if (not isinstance(x, mpc)) and is_exact_real_integer(x) and int(mp.re(x)) >= 0:
+        try:
+            return mp.gamma(x + 1)
+        except Exception:
+            return mp.mpf('inf')
+
     key = _ul_key(x)
     if key in _ul_cache:
         return _ul_cache[key]
 
-    max_n = 300
+    max_n = 220
     # absolute floor and small relative threshold
     abs_floor = mp.power(10, -max(8, int(mp.dps/3)))
     # relative factor for stopping (terms negligible compared to accumulated sum)
     rel_factor = mp.power(10, -12)
 
     _ensure_inner_cache(max_n)
     S = mp.mpf('0')
     consec_small = 0
     top = x  # C(x,1) = x
 
     for n in range(1, max_n + 1):
         inner = _inner_cache[n]
         denom = mp.mpf(2*n - 1)
         term = top * (inner / denom)
 
         if mp.isnan(term) or mp.isinf(term):
             _ul_cache[key] = mp.mpf('inf')
             return _ul_cache[key]
 
         # update S
         S_prev = S
         S = S + term
 
         abs_term = abs(term)
         # absolute stop
