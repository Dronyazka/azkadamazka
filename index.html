<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Height Map Water Fill (Pyodide)</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #111b31;
      --panel-2: #16223d;
      --text: #e8eefc;
      --muted: #9db0d7;
      --accent: #3b82f6;
      --ok: #22c55e;
      --warn: #f59e0b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(180deg, #090f1b 0%, #0f172a 100%);
      color: var(--text);
      min-height: 100vh;
    }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1.2rem;
      display: grid;
      gap: 1rem;
    }
    .card {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 1rem;
    }
    h1 { margin: 0; font-size: 1.5rem; }
    p { color: var(--muted); margin: 0.35rem 0 0; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.6rem;
      margin-top: 1rem;
    }
    .button, input[type="file"]::file-selector-button {
      background: var(--accent);
      color: white;
      border: 0;
      border-radius: 10px;
      padding: 0.6rem 0.9rem;
      font-weight: 600;
      cursor: pointer;
    }
    input[type="file"] {
      color: var(--muted);
      border: 1px dashed rgba(255, 255, 255, 0.25);
      border-radius: 10px;
      padding: 0.4rem;
      background: var(--panel-2);
    }
    .status { font-size: 0.95rem; color: var(--muted); }
    .status.ready { color: var(--ok); }
    .status.warn { color: var(--warn); }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
    }
    figure {
      margin: 0;
      background: var(--panel-2);
      border-radius: 12px;
      padding: 0.6rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    figcaption {
      color: var(--muted);
      font-size: 0.9rem;
      margin-top: 0.4rem;
      text-align: center;
    }
    canvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      image-rendering: pixelated;
      background: #020712;
    }
    .display-controls {
      margin-top: 0.8rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .display-controls fieldset {
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      margin: 0;
      padding: 0.45rem 0.7rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      min-width: 280px;
    }
    .display-controls legend {
      padding: 0 0.35rem;
      color: var(--text);
    }
    .display-controls label { display: inline-flex; align-items: center; gap: 0.3rem; }
    pre {
      margin: 0;
      background: #0b1325;
      padding: 0.8rem;
      border-radius: 10px;
      overflow-x: auto;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="card">
      <h1>Flood a B/W Equirectangular Height Map with Earth’s Water Volume</h1>
      <p>
        Upload a black/white (grayscale) equirectangular height map. Pyodide (Python in-browser)
        interprets brightness as terrain elevation, then solves for the water level that stores
        <strong>1.386 × 10<sup>9</sup> km³</strong> (Earth's ocean water volume).
      </p>

      <div class="controls">
        <input id="fileInput" type="file" accept="image/*" />
        <button id="processBtn" class="button" type="button" disabled>Process in Python</button>
        <span id="pyStatus" class="status">Loading Pyodide…</span>
      </div>

      <div class="display-controls">
        <fieldset>
          <legend>Transparency</legend>
          <label><input type="radio" name="transparency" value="none" checked /> None</label>
          <label><input type="radio" name="transparency" value="land" /> Transparent land</label>
          <label><input type="radio" name="transparency" value="sea" /> Transparent sea</label>
        </fieldset>
      </div>
    </section>

    <section class="grid">
      <figure>
        <canvas id="inputCanvas" width="1" height="1"></canvas>
        <figcaption>Input height map (grayscale interpreted as elevation)</figcaption>
      </figure>
      <figure>
        <canvas id="outputCanvas" width="1" height="1"></canvas>
        <figcaption>Flood result (blue = water depth, white = dry land; selectable transparency)</figcaption>
      </figure>
    </section>

    <section class="card">
      <pre id="stats">No image loaded yet.</pre>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
  <script>
    const fileInput = document.getElementById('fileInput');
    const processBtn = document.getElementById('processBtn');
    const pyStatus = document.getElementById('pyStatus');
    const stats = document.getElementById('stats');
    const transparencyInputs = document.querySelectorAll('input[name="transparency"]');

    const inputCanvas = document.getElementById('inputCanvas');
    const outputCanvas = document.getElementById('outputCanvas');
    const inCtx = inputCanvas.getContext('2d', { willReadFrequently: true });
    const outCtx = outputCanvas.getContext('2d');

    let pyodide;
    let sourceGray = null;
    let sourceWidth = 0;
    let sourceHeight = 0;
    let latestDepthMap = null;

    const pythonModule = `
import math

EARTH_WATER_KM3 = 1.386e9
EARTH_RADIUS_KM = 6371.0
MIN_ELEV_KM = -11.0
MAX_ELEV_KM = 9.0


def _pixel_area_weights(rows, cols):
    dlon = (2 * math.pi) / cols
    dlat = math.pi / rows
    weights = []
    for r in range(rows):
        lat = math.pi / 2 - (r + 0.5) * dlat
        strip_area = (EARTH_RADIUS_KM ** 2) * dlon * dlat * math.cos(lat)
        weights.append(strip_area)
    return weights


def _height_from_gray(gray):
    return MIN_ELEV_KM + (gray / 255.0) * (MAX_ELEV_KM - MIN_ELEV_KM)


def process_height_map(gray_values, rows, cols):
    if rows * cols != len(gray_values):
        raise ValueError("Input array size does not match rows*cols")

    heights = [_height_from_gray(g) for g in gray_values]
    row_weights = _pixel_area_weights(rows, cols)

    def volume_at(level):
        total = 0.0
        idx = 0
        for r in range(rows):
            area = row_weights[r]
            for _ in range(cols):
                h = heights[idx]
                if level > h:
                    total += (level - h) * area
                idx += 1
        return total

    low = min(heights)
    high = max(heights) + 30.0
    for _ in range(70):
        mid = 0.5 * (low + high)
        if volume_at(mid) < EARTH_WATER_KM3:
            low = mid
        else:
            high = mid
    sea_level = 0.5 * (low + high)

    flood_depth = []
    flooded_pixels = 0
    max_depth = 0.0
    total_volume = 0.0

    idx = 0
    for r in range(rows):
        area = row_weights[r]
        for _ in range(cols):
            d = max(0.0, sea_level - heights[idx])
            flood_depth.append(d)
            if d > 0:
                flooded_pixels += 1
                total_volume += d * area
                if d > max_depth:
                    max_depth = d
            idx += 1

    flooded_fraction = flooded_pixels / (rows * cols)
    return {
        "sea_level_km": sea_level,
        "volume_km3": total_volume,
        "target_km3": EARTH_WATER_KM3,
        "flooded_fraction": flooded_fraction,
        "max_depth_km": max_depth,
        "depth_map_km": flood_depth,
    }
`;

    async function initPyodideRuntime() {
      pyStatus.textContent = 'Loading Pyodide…';
      pyodide = await loadPyodide();
      await pyodide.runPythonAsync(pythonModule);
      pyStatus.textContent = 'Pyodide ready';
      pyStatus.classList.add('ready');
      processBtn.disabled = false;
    }

    function getTransparencyMode() {
      const selected = document.querySelector('input[name="transparency"]:checked');
      return selected ? selected.value : 'none';
    }

    function setCanvasResolution(width, height) {
      inputCanvas.width = width;
      inputCanvas.height = height;
      outputCanvas.width = width;
      outputCanvas.height = height;
    }

    function drawImageToInputCanvas(img) {
      const targetWidth = img.naturalWidth || img.width;
      const targetHeight = img.naturalHeight || img.height;

      setCanvasResolution(targetWidth, targetHeight);
      inCtx.clearRect(0, 0, targetWidth, targetHeight);
      inCtx.drawImage(img, 0, 0, targetWidth, targetHeight);
      const imageData = inCtx.getImageData(0, 0, targetWidth, targetHeight);
      sourceGray = imageDataToGrayArray(imageData);
      sourceWidth = targetWidth;
      sourceHeight = targetHeight;
      stats.textContent = `Image loaded at original resolution: ${targetWidth}×${targetHeight}. Click "Process in Python".`;
      latestDepthMap = null;
      outCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
    }

    function imageDataToGrayArray(imageData) {
      const data = imageData.data;
      const gray = new Uint8Array(imageData.width * imageData.height);
      for (let i = 0, p = 0; i < data.length; i += 4, p += 1) {
        gray[p] = (data[i] + data[i + 1] + data[i + 2]) / 3;
      }
      return gray;
    }

    function drawFloodDepth(depthMapKm, width, height) {
      let maxDepth = 0;
      const transparencyMode = getTransparencyMode();
      for (let i = 0; i < depthMapKm.length; i += 1) {
        if (depthMapKm[i] > maxDepth) maxDepth = depthMapKm[i];
      }

      const img = outCtx.createImageData(width, height);
      for (let i = 0; i < depthMapKm.length; i += 1) {
        const depth = depthMapKm[i];
        const idx = i * 4;
        const isLand = depth <= 0;

        if (isLand) {
          img.data[idx] = 245;
          img.data[idx + 1] = 245;
          img.data[idx + 2] = 245;
          img.data[idx + 3] = transparencyMode === 'land' ? 0 : 255;
        } else {
          const t = maxDepth > 0 ? Math.min(1, depth / maxDepth) : 0;
          img.data[idx] = Math.round(25 + 35 * (1 - t));
          img.data[idx + 1] = Math.round(75 + 80 * (1 - t));
          img.data[idx + 2] = Math.round(180 + 75 * t);
          img.data[idx + 3] = transparencyMode === 'sea' ? 0 : 255;
        }
      }
      outCtx.putImageData(img, 0, 0);
    }

    fileInput.addEventListener('change', () => {
      const file = fileInput.files?.[0];
      if (!file) return;
      const img = new Image();
      const objectUrl = URL.createObjectURL(file);
      img.onload = () => {
        drawImageToInputCanvas(img);
        URL.revokeObjectURL(objectUrl);
      };
      img.onerror = () => {
        URL.revokeObjectURL(objectUrl);
      };
      img.src = objectUrl;
    });

    transparencyInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (latestDepthMap && sourceWidth && sourceHeight) {
          drawFloodDepth(latestDepthMap, sourceWidth, sourceHeight);
        }
      });
    });

    processBtn.addEventListener('click', async () => {
      if (!sourceGray) {
        stats.textContent = 'Please upload an image first.';
        return;
      }
      processBtn.disabled = true;
      pyStatus.textContent = 'Running Python flood model…';
      pyStatus.classList.remove('warn');

      try {
        pyodide.globals.set('gray_values_js', sourceGray);
        pyodide.globals.set('rows_js', sourceHeight);
        pyodide.globals.set('cols_js', sourceWidth);

        const result = pyodide.runPython(`
result = process_height_map(gray_values_js, rows_js, cols_js)
result
`);

        const depthMapProxy = result.get('depth_map_km');
        const seaLevel = result.get('sea_level_km');
        const volume = result.get('volume_km3');
        const target = result.get('target_km3');
        const floodedFrac = result.get('flooded_fraction');
        const maxDepth = result.get('max_depth_km');
        latestDepthMap = Float32Array.from(depthMapProxy.toJs());

        drawFloodDepth(latestDepthMap, sourceWidth, sourceHeight);

        depthMapProxy.destroy();
        result.destroy();
        pyodide.globals.delete('gray_values_js');
        pyodide.globals.delete('rows_js');
        pyodide.globals.delete('cols_js');

        stats.textContent = [
          `Solved water level: ${seaLevel.toFixed(4)} km (relative to map's elevation scale)`,
          `Computed water volume: ${volume.toExponential(6)} km^3`,
          `Target Earth water volume: ${target.toExponential(6)} km^3`,
          `Flooded pixel fraction: ${(floodedFrac * 100).toFixed(2)}%`,
          `Maximum local water depth: ${maxDepth.toFixed(3)} km`,
          '',
          'Assumptions:',
          '- grayscale 0..255 maps linearly to elevation range [-11 km, +9 km]',
          '- image is equirectangular and each pixel uses spherical area weighting by latitude',
          '- "deepest parts" fill first by globally raising sea level until target volume is reached',
        ].join('\n');

        pyStatus.textContent = 'Done';
        pyStatus.classList.add('ready');
      } catch (err) {
        try {
          pyodide.globals.delete('gray_values_js');
          pyodide.globals.delete('rows_js');
          pyodide.globals.delete('cols_js');
        } catch {}
        pyStatus.textContent = 'Python processing failed';
        pyStatus.classList.add('warn');
        stats.textContent = String(err);
      } finally {
        processBtn.disabled = false;
      }
    });

    initPyodideRuntime().catch((err) => {
      pyStatus.textContent = 'Could not load Pyodide in this environment';
      pyStatus.classList.add('warn');
      stats.textContent = String(err);
    });
  </script>
</body>
</html>
